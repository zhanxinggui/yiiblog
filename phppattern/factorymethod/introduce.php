<?php
/*
 * 我对工厂模式的理解，感觉其中核心的部分，就是完全的封装，我只需要提供参数给你，你怎么做我不管，然后你要返回我需要的东西，
 * 有一个看似脑筋急转弯的东西，其实是对工厂模式的精髓理解：如何把大象放进冰箱？答案是三步1 打开冰箱 2把大象放进去 3 关上冰箱
 * 在这里不是一个笑话，也不是脑筋急转弯，工厂模式正是如此，
 * 我只管把我的数据给你，然后去取得我想要的返回，其它一切统统封装，降低代码的耦合性，无需每次重复再写一大堆代码。
 */

//1 我们需要有一个链接数据库的接口，当然，这个接口没有任何的实际的操作，它只是一个抽象
interface Db_connect{
	function getconnect();
}
//接口的意义就是如此，接口的意义就是规范类里面的方法，不去做任何实际的动作，
//但是借口里面的方法，实现的类必须用到，否则没有任何意义


//2 我们需要一个具体操作的类去实现接口的方法
class db_conn implements Db_connect{

	protected $ip;

	protected $username;

	protected $password;

	protected $db_name;

	protected static $a = null;

	private function __construct(){

		mysql_connect($this->ip,$this->username,$this->password) or die(mysql_error());

	}

	static function connet_db(){

		if(self::a == null){

			self::a == new db_conn();

		}

	}

}

//3 我们需要一个工厂，去具体的实例化这个类

class factory{
	public function create_conn(){
		db_conn::connet_db();
	}
}

/*工厂类负责具体实例化哪个类，而其他的程序逻辑都是针对DB这个接口进行操作，这就是“针对接口编程”。责任都被推卸给工厂类了，
     当然你也可以继续定义工厂接口，继续把责任上抛，这就演变成抽象工厂(Abstract Factory)。

　整个过程中接口不负责任何具体操作，其他的程序要连接数据库的话，只需要构造一个DB对象就OK，而不管工厂类如何变化。
     这就是接口的意义----抽象。
     
    以下的话说明了三种工厂模式的作用

  1, 简单工厂解决的是: 工厂只有1个,产品有几个的问题

            简单工厂模式中,一个工厂类处于对产品类实例化调用的中心位置上,它决定那一个产品类应当被实例化

  2, 工厂方法解决的是: 具体的工厂有多个,而产品只有一种类型的问题

            实质上它是让工厂实现了抽象的工厂接口，它把具体怎么生产一种东西，放在具体的工厂去实现了，所谓”延迟到子类中实现“

  3,抽象工厂解决的是 : 具体工厂有几个,产品有好几种类型的问题   

*/



